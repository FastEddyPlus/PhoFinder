<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>PhoFinder</title>
  <style>
    html, body { height: 100%; margin: 0; }
    #map { height: 100%; width: 100%; }
    .widget {
      position: absolute; top: 16px; left: 16px; z-index: 5;
      background: #fff; border-radius: 14px; box-shadow: 0 6px 18px rgba(0,0,0,.15);
      padding: 12px 14px; font-family: ui-sans-serif, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      max-width: 360px; display: grid; grid-template-columns: 1fr auto; gap: 8px 12px; align-items: center;
    }
    .widget h1 { margin: 0; font-size: 16px; font-weight: 700; line-height: 1.2; }
    .widget .sub { grid-column: 1 / -1; color: #444; font-size: 13px; }
    .widget .badge { display: inline-block; padding: 4px 8px; border-radius: 999px; background: #f1f5f9; font-size: 12px; }
    .widget button { border: 0; background: #111827; color: #fff; padding: 8px 10px; border-radius: 10px; cursor: pointer; font-size: 13px; }
    .widget button[disabled] { opacity: .6; cursor: not-allowed; }
    .label { position: absolute; transform: translate(-50%, -100%); background: #111827; color: #fff; padding: 6px 8px; border-radius: 8px; font-size: 12px; white-space: nowrap; pointer-events: none; }
  </style>
</head>
<body>
  <div id="map"></div>
  <div class="widget" id="info">
    <div>
      <h1>PhoFinder</h1>
      <div class="sub" id="status">Locating you…</div>
    </div>
    <button id="myloc">Use my location</button>
    <button id="recenter" disabled>Recenter</button>
    <div class="sub"><span class="badge" id="name">—</span> <span class="badge" id="distance">—</span></div>
    <div class="sub" id="steps"></div>
  </div>

  <script>
    const KEYWORD = 'vietnamese';
    const PLACE_TYPE = 'restaurant';
    let map, placesService, directionsService, directionsRenderer;
    let userMarker = null, placeMarker = null, arrowLine = null, labelOverlay = null;
    let userPos = null;

    const $ = (id) => document.getElementById(id);
    const setStatus = (t) => { $('status').textContent = t; };
    const metersToHuman = (m) => m < 1000 ? `${Math.round(m)} m` : `${(m/1000).toFixed((m/1000)<10?1:0)} km`;

    function placeMarkerAt(position, options = {}) { return new google.maps.Marker({ position, map, ...options }); }
    function drawArrow(from, to) {
      if (arrowLine) arrowLine.setMap(null);
      arrowLine = new google.maps.Polyline({ path: [from, to], strokeOpacity: 0.7, strokeWeight: 4, icons: [{ icon: { path: google.maps.SymbolPath.FORWARD_CLOSED_ARROW, scale: 3 }, offset: '100%' }] });
      arrowLine.setMap(map);
    }
    function attachLabel(position, text) {
      if (labelOverlay) labelOverlay.setMap(null);
      const div = document.createElement('div');
      div.className = 'label';
      div.textContent = text;
      class LabelOverlay extends google.maps.OverlayView {
        onAdd() { this.getPanes().floatPane.appendChild(div); }
        draw() {
          const proj = this.getProjection();
          const pt = proj.fromLatLngToDivPixel(position);
          div.style.left = pt.x + 'px';
          div.style.top = pt.y + 'px';
          div.style.position = 'absolute';
        }
        onRemove() { if (div.parentNode) div.parentNode.removeChild(div); }
      }
      labelOverlay = new LabelOverlay();
      labelOverlay.setMap(map);
    }

    function renderStepsFromDirections(dirResult){
      const c = $('steps');
      if (!c) return;
      try {
        const leg = dirResult.routes[0].legs[0];
        const steps = leg.steps || [];
        if (!steps.length){ c.innerHTML = ''; return; }
        const items = steps.map(s => {
          const text = (s.instructions || '').replace(/<[^>]+>/g,'');
          const dist = s.distance && s.distance.text ? ` — ${s.distance.text}` : '';
          return `<li>${text}${dist}</li>`;
        }).join('');
        c.innerHTML = `<ol style="margin:8px 0 0 18px; padding:0;">${items}</ol>`;
      } catch (e) {
        $('steps').innerHTML = '';
      }
    }

    function clearSteps(){ const c=$('steps'); if(c) c.innerHTML=''; }

    function clearPlaceArtifacts(){
      if (placeMarker) { placeMarker.setMap(null); placeMarker = null; }
      if (arrowLine)   { arrowLine.setMap(null);   arrowLine   = null; }
      if (labelOverlay){ labelOverlay.setMap(null); labelOverlay= null; }
      if (directionsRenderer) { directionsRenderer.set('directions', null); }
      clearSteps();
    }

    function updateInfo(nameText, subText) {
      $('name').textContent = nameText || '—';
      $('distance').textContent = subText || '—';
    }

    function setUserPosition(latLng, recenter = true) {
      userPos = latLng;
      if (!userMarker) {
        userMarker = placeMarkerAt(userPos, {
          title: 'You are here', draggable: true,
          icon: { path: google.maps.SymbolPath.CIRCLE, scale: 8, fillColor: '#2563eb', fillOpacity: 1, strokeColor: '#1e40af', strokeWeight: 2 }
        });
        userMarker.addListener('dragend', (e) => { setUserPosition(e.latLng, false); runSearch(); });
      } else {
        userMarker.setPosition(userPos);
      }
      if (recenter) map.panTo(userPos);
    }

    function nearbyVietnamese(location) {
      return new Promise((resolve, reject) => {
        placesService.nearbySearch({ location, rankBy: google.maps.places.RankBy.DISTANCE, type: PLACE_TYPE, keyword: KEYWORD }, (results, status) => {
          if (status !== google.maps.places.PlacesServiceStatus.OK) {
            reject(new Error('Places search failed: ' + status));
          } else {
            resolve(results || []);
          }
        });
      });
    }

    function bestByWalking(orig, results) {
      return new Promise((resolve, reject) => {
        if (!results.length) return reject(new Error('No Vietnamese restaurants found nearby.'));
        const svc = new google.maps.DistanceMatrixService();
        const destinations = results.slice(0, 20).map(r => r.geometry.location);
        svc.getDistanceMatrix({
          origins: [orig],
          destinations,
          travelMode: google.maps.TravelMode.WALKING,
          unitSystem: google.maps.UnitSystem.METRIC,
        }, (res, status) => {
          if (status !== 'OK' || !res.rows || !res.rows[0]) {
            return reject(new Error('Distance Matrix failed: ' + status));
          }
          const elems = res.rows[0].elements;
          let bestIdx = -1, bestSec = Infinity;
          elems.forEach((el, i) => {
            if (el.status === 'OK' && el.duration && el.duration.value < bestSec) {
              bestSec = el.duration.value; bestIdx = i;
            }
          });
          if (bestIdx === -1) return reject(new Error('No walkable routes found.'));
          resolve({ place: results[bestIdx], element: elems[bestIdx] });
        });
      });
    }

    async function runSearch() {
      try {
        if (!userPos) return;
        clearPlaceArtifacts();
        setStatus('Searching nearby Vietnamese restaurants…');
        const results = await nearbyVietnamese(userPos);
        let chosenPlace, dmElement;
        try {
          const byWalk = await bestByWalking(userPos, results);
          chosenPlace = byWalk.place;
          dmElement   = byWalk.element;
        } catch (err) {
          console.warn(err.message);
          setStatus('Distance Matrix unavailable, using straight-line distance.');
          const nearest = results.reduce((best, cur) => {
            const a = userPos; const b = cur.geometry.location;
            const d = google.maps.geometry && google.maps.geometry.spherical
              ? google.maps.geometry.spherical.computeDistanceBetween(a, b)
              : Math.hypot(a.lat() - b.lat(), a.lng() - b.lng());
            return (!best || d < best.d) ? { place: cur, d } : best;
          }, null);
          chosenPlace = nearest.place;
          dmElement   = { distance: { text: metersToHuman(nearest.d), value: nearest.d }, duration: null };
        }

        const placeLoc = chosenPlace.geometry.location;
        placeMarker = placeMarkerAt(placeLoc, { title: chosenPlace.name });

        const distText = dmElement.distance ? dmElement.distance.text : '';
        const durText  = dmElement.duration ? dmElement.duration.text  : '';
        const label    = durText ? `Walking: ${durText} • ${distText}` : distText;
        updateInfo(chosenPlace.name, label);
        attachLabel(placeLoc, `${chosenPlace.name} • ${label}`);

        try {
          const res = await directionsService.route({
            origin: userPos,
            destination: placeLoc,
            travelMode: google.maps.TravelMode.WALKING
          });
          directionsRenderer.setDirections(res);
          renderStepsFromDirections(res);
          const rb = res.routes && res.routes[0] && res.routes[0].bounds;
          if (rb) {
            map.fitBounds(rb, 80);
          } else {
            const bounds = new google.maps.LatLngBounds(); bounds.extend(userPos); bounds.extend(placeLoc); map.fitBounds(bounds, 80);
          }
        } catch (e) {
          console.warn('Directions failed, fallback to arrow:', e);
          clearSteps();
          drawArrow(userPos, placeLoc);
          const bounds = new google.maps.LatLngBounds(); bounds.extend(userPos); bounds.extend(placeLoc); map.fitBounds(bounds, 80);
        }
      } catch (e) {
        setStatus(e.message);
        updateInfo('—', '—');
      }
    }

    function getCurrentPosition(options = { enableHighAccuracy: true, timeout: 12000 }) {
      return new Promise((resolve, reject) => {
        if (!navigator.geolocation) return reject(new Error('Geolocation not supported by this browser.'));
        navigator.geolocation.getCurrentPosition(resolve, reject, options);
      });
    }

    function initMap() {
      map = new google.maps.Map(document.getElementById('map'), { center: { lat: 0, lng: 0 }, zoom: 15 });
      placesService = new google.maps.places.PlacesService(map);
      directionsService = new google.maps.DirectionsService();
      directionsRenderer = new google.maps.DirectionsRenderer({ suppressMarkers: true, preserveViewport: true, polylineOptions: { strokeOpacity: 0.9, strokeWeight: 5 } });
      directionsRenderer.setMap(map);

      map.addListener('click', (e) => { setUserPosition(e.latLng); runSearch(); });

      (async () => {
        try {
          const pos  = await getCurrentPosition();
          const here = new google.maps.LatLng(pos.coords.latitude, pos.coords.longitude);
          setUserPosition(here);
          $('recenter').disabled = false;
          await runSearch();
        } catch (err) {
          setStatus('Click anywhere on the map to set your location.');
          map.setZoom(3);
        }
      })();

      $('recenter').addEventListener('click', () => { if (userPos) map.panTo(userPos); });
      $('myloc').addEventListener('click', async () => {
        setStatus('Getting your current location…');
        try {
          const pos  = await getCurrentPosition();
          const here = new google.maps.LatLng(pos.coords.latitude, pos.coords.longitude);
          setUserPosition(here);
          await runSearch();
        } catch (e) {
          setStatus('Location blocked. You can still click the map to set your position.');
        }
      });
    }

    window.initMap = initMap;
  </script>

  <script async defer src="https://maps.googleapis.com/maps/api/js?key=AIzaSyDS_pl74xQdpEKXyf1NKsfgVhBBuN-nyg0&v=weekly&libraries=places,geometry&callback=initMap"></script>
</body>
</html>