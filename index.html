<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Closest Vietnamese Restaurant (Walking)</title>
  <style>
    html, body { height: 100%; margin: 0; }
    #map { height: 100%; width: 100%; }
    .widget {
      position: absolute; top: 16px; left: 16px; z-index: 5;
      background: #fff; border-radius: 14px; box-shadow: 0 6px 18px rgba(0,0,0,.15);
      padding: 12px 14px;
      font-family: ui-sans-serif, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      max-width: 360px; display: grid; grid-template-columns: 1fr auto; gap: 8px 12px; align-items: center;
    }
    .widget h1 { margin: 0; font-size: 16px; font-weight: 700; line-height: 1.2; }
    .widget .sub { grid-column: 1 / -1; color: #444; font-size: 13px; }
    .widget .badge { display: inline-block; padding: 4px 8px; border-radius: 999px; background: #f1f5f9; font-size: 12px; }
    .widget button { border: 0; background: #111827; color: #fff; padding: 8px 10px; border-radius: 10px; cursor: pointer; font-size: 13px; }
    .widget button[disabled] { opacity: .6; cursor: not-allowed; }
    .label {
      position: absolute; transform: translate(-50%, -100%); background: #111827; color: #fff;
      padding: 6px 8px; border-radius: 8px; font-size: 12px; white-space: nowrap; pointer-events: none;
    }
  </style>
</head>
<body>
  <div id="map"></div>

  <div class="widget" id="info">
    <div>
      <h1>Closest Vietnamese restaurant</h1>
      <div class="sub" id="status">Locating you…</div>
    </div>
    <button id="myloc">Use my location</button>
    <button id="recenter" disabled>Recenter</button>
    <div class="sub"><span class="badge" id="name">—</span> <span class="badge" id="distance">—</span></div>
  </div>

  <script>
    // --- Config ---
    const KEYWORD = 'vietnamese';
    const PLACE_TYPE = 'restaurant';

    // Globals
    let map, placesService;
    let userMarker = null, placeMarker = null, arrowLine = null, labelOverlay = null;
    let userPos = null;

    // Utilities
    const $ = (id) => document.getElementById(id);
    const setStatus = (t) => { $('status').textContent = t; };
    const metersToHuman = (m) => m < 1000 ? `${Math.round(m)} m` : `${(m/1000).toFixed((m/1000)<10?1:0)} km`;

    function placeMarkerAt(position, options = {}) {
      return new google.maps.Marker({ position, map, ...options });
    }

    function drawArrow(from, to) {
      if (arrowLine) arrowLine.setMap(null);
      arrowLine = new google.maps.Polyline({
        path: [from, to],
        strokeOpacity: 0.7, strokeWeight: 4,
        icons: [{ icon: { path: google.maps.SymbolPath.FORWARD_CLOSED_ARROW, scale: 3 }, offset: '100%' }]
      });
      arrowLine.setMap(map);
    }

    function attachLabel(position, text) {
      // Remove previous overlay
      if (labelOverlay) labelOverlay.setMap(null);
      const div = document.createElement('div');
      div.className = 'label';
      div.textContent = text;

      class LabelOverlay extends google.maps.OverlayView {
        onAdd() { this.getPanes().floatPane.appendChild(div); }
        draw() {
          const proj = this.getProjection();
          const pt = proj.fromLatLngToDivPixel(position);
          div.style.left = pt.x + 'px';
          div.style.top  = pt.y + 'px';
          div.style.position = 'absolute';
        }
        onRemove() { if (div.parentNode) div.parentNode.removeChild(div); }
      }
      labelOverlay = new LabelOverlay();
      labelOverlay.setMap(map);
    }

    function clearPlaceArtifacts() {
      if (placeMarker) { placeMarker.setMap(null); placeMarker = null; }
      if (arrowLine)   { arrowLine.setMap(null);   arrowLine   = null; }
      if (labelOverlay){ labelOverlay.setMap(null); labelOverlay= null; }
    }

    function updateInfo(nameText, subText) {
      $('name').textContent = nameText || '—';
      $('distance').textContent = subText || '—';
    }

    function setUserPosition(latLng, recenter = true) {
      userPos = latLng;
      if (!userMarker) {
        userMarker = placeMarkerAt(userPos, {
          title: 'You are here', draggable: true,
          icon: { path: google.maps.SymbolPath.CIRCLE, scale: 8,
                  fillColor: '#2563eb', fillOpacity: 1, strokeColor: '#1e40af', strokeWeight: 2 }
        });
        userMarker.addListener('dragend', (e) => { setUserPosition(e.latLng, false); runSearch(); });
      } else {
        userMarker.setPosition(userPos);
      }
      if (recenter) map.panTo(userPos);
    }

    function nearbyVietnamese(location) {
      return new Promise((resolve, reject) => {
        placesService.nearbySearch({
          location,
          rankBy: google.maps.places.RankBy.DISTANCE,
          type: PLACE_TYPE,
          keyword: KEYWORD
        }, (results, status) => {
          if (status !== google.maps.places.PlacesServiceStatus.OK) {
            reject(new Error('Places search failed: ' + status));
          } else {
            resolve(results || []);
          }
        });
      });
    }

    function bestByWalking(orig, results) {
      return new Promise((resolve, reject) => {
        if (!results.length) return reject(new Error('No Vietnamese restaurants found nearby.'));
        const svc = new google.maps.DistanceMatrixService();
        const destinations = results.slice(0, 20).map(r => r.geometry.location);
        svc.getDistanceMatrix({
          origins: [orig],
          destinations,
          travelMode: google.maps.TravelMode.WALKING,
          unitSystem: google.maps.UnitSystem.METRIC,
        }, (res, status) => {
          if (status !== 'OK' || !res.rows || !res.rows[0]) {
            return reject(new Error('Distance Matrix failed: ' + status));
          }
          const elems = res.rows[0].elements;
          let bestIdx = -1, bestSec = Infinity;
          elems.forEach((el, i) => {
            if (el.status === 'OK' && el.duration && el.duration.value < bestSec) {
              bestSec = el.duration.value; bestIdx = i;
            }
          });
          if (bestIdx === -1) return reject(new Error('No walkable routes found.'));
          resolve({ place: results[bestIdx], element: elems[bestIdx] });
        });
      });
    }

    async function runSearch() {
      try {
        if (!userPos) return;
        clearPlaceArtifacts();
        setStatus('Searching nearby Vietnamese restaurants…');

        const results = await nearbyVietnamese(userPos);
        let chosenPlace, dmElement;

        try {
          const byWalk = await bestByWalking(userPos, results);
          chosenPlace = byWalk.place;
          dmElement   = byWalk.element;
        } catch (err) {
          console.warn(err.message);
          setStatus('Distance Matrix unavailable, using straight-line distance.');
          const nearest = results.reduce((best, cur) => {
            const a = userPos; const b = cur.geometry.location;
            const d = (google.maps.geometry && google.maps.geometry.spherical)
              ? google.maps.geometry.spherical.computeDistanceBetween(a, b)
              : Math.hypot(a.lat() - b.lat(), a.lng() - b.lng());
            return (!best || d < best.d) ? { place: cur, d } : best;
          }, null);
          chosenPlace = nearest.place;
          dmElement   = { distance: { text: metersToHuman(nearest.d), value: nearest.d }, duration: null };
        }

        const placeLoc = chosenPlace.geometry.location;
        placeMarker = placeMarkerAt(placeLoc, { title: chosenPlace.name });

        const distText = dmElement.distance ? dmElement.distance.text : '';
        const durText  = dmElement.duration ? dmElement.duration.text  : '';
        const label    = durText ? `Walking: ${durText} • ${distText}` : distText;
        updateInfo(chosenPlace.name, label);
        drawArrow(userPos, placeLoc);
        attachLabel(placeLoc, `${chosenPlace.name} • ${label}`);

        const bounds = new google.maps.LatLngBounds();
        bounds.extend(userPos); bounds.extend(placeLoc);
        map.fitBounds(bounds, 80);
      } catch (e) {
        setStatus(e.message);
        updateInfo('—', '—');
      }
    }

    function getCurrentPosition(options = { enableHighAccuracy: true, timeout: 12000 }) {
      return new Promise((resolve, reject) => {
        if (!navigator.geolocation) return reject(new Error('Geolocation not supported by this browser.'));
        navigator.geolocation.getCurrentPosition(resolve, reject, options);
      });
    }

    function initMap() {
      map = new google.maps.Map(document.getElementById('map'), { center: { lat: 0, lng: 0 }, zoom: 15 });
      placesService = new google.maps.places.PlacesService(map);

      // Click to drop yourself anywhere
      map.addListener('click', (e) => { setUserPosition(e.latLng); runSearch(); });

      // Try geolocate first
      (async () => {
        try {
          const pos  = await getCurrentPosition();
          const here = new google.maps.LatLng(pos.coords.latitude, pos.coords.longitude);
          setUserPosition(here);
          $('recenter').disabled = false;
          await runSearch();
        } catch (err) {
          setStatus('Click anywhere on the map to set your location.');
          map.setZoom(3);
        }
      })();

      // Buttons
      $('recenter').addEventListener('click', () => { if (userPos) map.panTo(userPos); });
      $('myloc').addEventListener('click', async () => {
        setStatus('Getting your current location…');
        try {
          const pos  = await getCurrentPosition();
          const here = new google.maps.LatLng(pos.coords.latitude, pos.coords.longitude);
          setUserPosition(here);
          await runSearch();
        } catch (e) {
          setStatus('Location blocked. You can still click the map to set your position.');
        }
      });
    }

    // Expose for callback
    window.initMap = initMap;
  </script>

  <!-- Load Maps exactly once (hardcoded key). Make sure this is the ONLY loader on the page. -->
  <script async defer
    src="https://maps.googleapis.com/maps/api/js?key=AIzaSyDS_pl74xQdpEKXyf1NKsfgVhBBuN-nyg0&v=weekly&libraries=places,geometry&callback=initMap">
  </script>
</body>
</html>